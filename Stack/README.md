# Сравнение скорости работы динамического массива и односвязного списка

## Описание

В данном проекте проводится сравнение скорости работы стека, реализованного на динамическом массиве, и на односвязном списке. Для этого проводятся различные тесты, включая вставку, удаление и генерацию случайных чисел.

## Результаты тестов

### Тест 1

Надо запушить 10^6 интов, потом удалить половину элементов и запушить четверть - останется 750000 интов. Повторять удаление половины и вставку четверти, пока не останется в стеке меньше 100000 элементов.

#### Результаты для стека на динамическом массиве:
- Общее время работы: 0.038000 секунд

| Number | Stack Size | Time (seconds) |
|--------|------------|----------------|
|   1    |   750000   |     0.007      |
|   2    |   562500   |     0.005      |
|   3    |   421875   |     0.008      |
|   4    |   316406   |     0.005      |
|   5    |   237304   |     0.003      |
|   6    |   177978   |     0.002      |    
|   7    |   133483   |     0.002      |
|   8    |   100112   |     0.002      |
|   9    |   75084    |     0.002      |

- Среднее значение: 0.004 секунд

#### Результаты для стека на односвязном списке:
- Общее время работы: 0.425000 секунд

| Number | Stack Size | Time (seconds) |
|--------|------------|----------------|
|   1    |   750000   |     0.110      |
|   2    |   562500   |     0.085      |
|   3    |   421875   |     0.063      |
|   4    |   316406   |     0.047      |
|   5    |   237304   |     0.040      |
|   6    |   177978   |     0.027      |
|   7    |   133483   |     0.023      |
|   8    |   100112   |     0.018      |
|   9    |   75084    |     0.012      |

- Среднее значение: 0.047 секунд

### Тест 2

Надо запушить 10^6 интов, потом 100 раз удалить 10000 элементов и добавить столько же. Далее как в первом тесте провести 9 итераций удаления-вставки и снова 100 раз удалить 10000 элементов и добавить столько же.

#### Результаты для стека на динамическом массиве:
- Общее время работы: 0.156000 секунд
- Remove add 10000 elements 100 times in 0.051000 second
- after the analogy of the first test time 0.069000 size 75084 
- Remove add 10000 elements 100 times 0.036000
- Среднее значение: 0.152500

#### Результаты для стека на односвязном списке:
- Общее время работы: 1.598 секунд
- Remove add 10000 elements 100 times 0.55
- after the analogy of the first test time 0.628000 size 75084
- Remove add 10000 elements 100 times 0.420000
- Среднее значение: 1.77400 секунд

### Тест 3

Надо научиться средствами языка генерировать случайные числа из множества {1,2}. Далее сначала довести размер стека до миллиона, а потом выполнить миллион инструкций следующего вида: каждое выпадение единицы добавлять элемент, а на двойку - попать из стека. Засекать время после доведения размера стека до миллиона.

#### Результаты для стека на динамическом массиве:
- Общее время работы: 2.832000 секунд
- Push and Pop 1000000 time in 2.832000 second
- Среднее значение: 2.891000 секунд

#### Результаты для стека на односвязном списке:
- Общее время работы: 0.678000 секунд
- third test linked:
- Push and Pop 1000000 time in 0.678000 second
- Среднее значение: 0.723000

### Тест 4 (График времени вставки в стек на массиве)

![График времени вставки в стек на массиве](https://github.com/avarxx/Lab2024/blob/Review/Stack/plot.png)

### Вывод 
Из результатов проведенных тестов видно, что стек, реализованный на динамическом массиве, имеет значительно более высокую производительность по  сравнению со стеком на односвязном списке.

Стек на динамическом массиве является более эффективным выбором, при необходимости частых операций добавления и удаления элементов. Стек на списке имеет преимущество в том что размер стека может быть изменен в любое время и не с такой затратой по времени как стек на линамическом массиве

# Cтоимость операций

$$
\Phi(c, s)=\begin{cases}
2s - c, & \text{если } s \geqslant \frac{1}{2}c \\
\frac{1}{2}c - s, & \text{если } s < \frac{1}{2}c
\end{cases}
$$

# Стоимость операции добавления элемента

Пусть у нас единицей стоимости операции является одна монетка. Тогда при каждой операции `push(x)`, при которой нам не требуется копирование, мы будем использовать три монетки. Из них одна пойдёт на стоимость самой этой операции, а две будут в резерве , мы будем класть по одной монетке к -элементам с номерами $i$ и $\displaystyle i − frac{n}{2}$ В итоге, к тому моменту, как массив будет заполнен, рядом с каждым элементом будет лежать по одной монетке, которую мы и можем использовать на его копирование в новый массив.
-Таким образом, амортизационная стоимость каждой операции `push(x)` — 3 и среднее время её работы — O(1)

- Если $\frac{s}{c} = 1$, массив расширяется:
    $$a_i = t_i + \left(\Phi(2c, s+1)\right) - \left(\Phi(c, s)\right) \\
    = (s+1) + \left(2(s+1) - 2c\right) - \left(2s - c\right) = 3$$
  
-   Если $1 > \frac{s}{c} \geqslant \frac{1}{2}$, массив не расширяется:
    $$a_i = t_i + \Phi(c, s+1) - \Phi(c, s) \\
    =  1 + (2(s+1) - c) - (2s - c) = 3$$  

-   Если $\frac{s}{c} < \frac{1}{2}$ и $\frac{s+1}{c} \geqslant \frac{1}{2}$, массив не расширяется:
    $$a_i = t_i + \Phi(c, s+1) - \Phi(c, s) \\
    = 1 + (2(s+1) - c) - \left(\frac{1}{2}c - s\right) \\
    = 3 + 3s - \frac{3}{2}c \\
    = 3 + \frac{3s}{c}c - \frac{3}{2}c \\
    < 3 + \frac{3}{2}c - \frac{3}{2}c = 3$$  

-   Если $\frac{s}{c} < \frac{1}{2}$ и $\frac{s+1}{c} < \frac{1}{2}$,
    массив не расширяется:
    $$a_i = t_i + \Phi(c, s+1) - \Phi(c, s) \\
        = 1 + \left(\frac{1}{2}c - (s+1)\right) - \left(\frac{1}{2}c - s\right) = 0$$

# Стоимость операции удаления элемента

При каждой операции будем использовать две монетки. Одну из них потратим на само удаление элемента, другую на элемент, стоящий на позиции $\displaystyle i \text{ mod} \frac{n}{4}$.
-Тогда даже в самом худшем случае у каждого элемента из первых $frac{n}{4}$
-будет по монете и на удаление надо будет потратить только 1 монету.

-   Если $\frac{s}{c} = \frac{1}{4}$, массив сужается:
-   $$a_i = t_i + \Phi\left(\frac{c}{2}, s-1\right) - \Phi(c, s) \\
        = s + \left(\frac{1}{2} \cdot \frac{1}{2}c - (s-1)\right) - \left(\frac{1}{2}c - s\right) \\
        = 1 - \frac{1}{4}c + s = 1$$

-   Если $\frac{1}{4} < \frac{s}{c} < \frac{1}{2}$, массив не сужается:
    $$a_i = t_i + \Phi(c, s-1) - \Phi(c, s) \\
        = 1 + \left(\frac{1}{2}c - (s-1)\right) - \left(\frac{1}{2}c - s\right) = 2$$

-   Если $\frac{s}{c} \geqslant \frac{1}{2}$ и
    $\frac{s-1}{c} < \frac{1}{2}$, массив не сужается:
    $$a_i = t_i + \Phi(c, s-1) - \Phi(c, s) \\
        = 1 + \left(\frac{1}{2}c - (s-1)\right) - (2s - c) = 2$$

-   Если $\frac{s}{c} > \frac{1}{2}$, массив не сужается:
    $$a_i = t_i + \Phi(c, s-1) - \Phi(c, s) \\
        = 1 + (2(s-1) - c) - (2s - c) = 0$$

